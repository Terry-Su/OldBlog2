{"blogs":[{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/EN-Blogs/Technology/Algorithm/Topic/Vivid Metaphor of Data Structures/Vivid Metaphor of Data Structures.md","relativeClientUrl":"blog/detail/vivid-metaphor-of-data-structures.html","relativeClientPropsUrl":"All/Technology/Algorithm/Topic/Vivid Metaphor of Data Structures/props.json","name":"Vivid Metaphor of Data Structures","markedHtml":"<p>Data structures are abstract, sometimes hard to be understood. However, vivid metaphor helps us to master them better.  </p>\n<p>Data strcutres included in this article:</p>\n<ul>\n<li>stack</li>\n<li>queue</li>\n<li>linked list</li>\n</ul>\n<h2 id=\"stack\">Stack</h2>\n<p>First, let&#39;s see stack&#39;s core features:</p>\n<ul>\n<li><code>push( item )</code>: push an item at end</li>\n<li><code>pop()</code>: remove an item from end</li>\n<li><code>peek()</code>: get the end element</li>\n</ul>\n<p>I found a <a href=\"https://jshilpa.com/stacks-in-a-nutshell-learning-through-examples/\">very visual example</a> before, that&#39;s an open chips box.   </p>\n<p>And to corresponse with our development habbit(count index from left to right), I push it down.   </p>\n<p><img src=\"https://terry-su.github.io/BlogCDN/images/pringles.jpg\" alt=\"\">      </p>\n<ul>\n<li>we push a chip into box: <code>push( chip )</code></li>\n<li>we take a chip from box: <code>pop()</code></li>\n<li>current top chip in box: <code>peek()</code></li>\n</ul>\n<h2 id=\"queue\">Queue</h2>\n<p>Queue is similiar to stack, but easiler to learn.   </p>\n<p>Queue&#39;s key features are:</p>\n<ul>\n<li><code>enqueue( item )</code>: push an item at end </li>\n<li><code>dequeue()</code>: remove an item from front</li>\n<li><code>peekFront()</code>: get the front item</li>\n<li><code>peekEnd()</code>: get the end item</li>\n</ul>\n<p>Suppose there&#39;re some people queuing to use ATM.  </p>\n<p><img src=\"https://terry-su.github.io/BlogCDN/images/queue-for-atm.png\" alt=\"\">  </p>\n<ul>\n<li>at end comes a new guy: <code>enqueue( person )</code></li>\n<li>front guy has done and leave: <code>dequeue()</code></li>\n<li>current front guy: <code>peekFront()</code></li>\n<li>current last guy: <code>peekEnd()</code></li>\n</ul>\n<h2 id=\"linked-list\">Linked List</h2>\n<p>Linked list consists of nodes, and each node can have a link to another link, like a chain.</p>\n<p><img src=\"https://terry-su.github.io/BlogCDN/images/chain.jpg\" alt=\"\">  </p>\n<p>Mock its main concept via codes:</p>\n<pre><code class=\"language-js\">const nodeC = { link: null }\nconst nodeB = { link: nodeC }\nconst nodeA = { link: nodeB }\n\nconst linkedList = { head: nodeA }</code></pre>\n","createTime":"2019/01/17 12:39","categorySequence":["All","Technology","Algorithm","Topic"],"tags":[],"introduction":"Data structures are abstract, sometimes hard to be understood. However, vivid metaphor helps us to master...","uniqueHtmlName":"vivid-metaphor-of-data-structures","blogProps":{"createTime":"2019/01/17 12:39","comment":"15"}},{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/EN-Blogs/Technology/Algorithm/Sorting Algorithm/Demonstrate Sorting Algorithms with Animated Demos/Demonstrate Sorting Algorithms with Animated Demos.md","relativeClientUrl":"blog/detail/demonstrate-sorting-algorithms-with-animated-demos.html","relativeClientPropsUrl":"All/Technology/Algorithm/Sorting Algorithm/Demonstrate Sorting Algorithms with Animated Demos/props.json","name":"Demonstrate Sorting Algorithms with Animated Demos","markedHtml":"<p><img src=\"https://terry-su.github.io/BlogCDN/images/simpson-evolution.jpg\" alt=\"\">    </p>\n<p>After learning common sorting algorithms, feel like demonstrating them using not only brief description but also animated demos.</p>\n<p>Here contains 6 sorting algorithms, half are simple, half are advanced.</p>\n<ul>\n<li>Bubble sort</li>\n<li>Selection sort</li>\n<li>Insertion sort</li>\n<li>~</li>\n<li>Merge sort</li>\n<li>Shell sort</li>\n<li>Quick sort</li>\n</ul>\n<h2 id=\"bubble-sort\">Bubble sort</h2>\n<p>This maybe the simplest sort, notoriously slow though.<br>Suppose we were arranging a queue of baseball players by their height. \nStart from leftmost.</p>\n<ol>\n<li>compare two players </li>\n<li>if the one on the left is taller, swap them. Otherwise, no action.</li>\n<li>move one position right</li>\n</ol>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/algorithm/bubble-sort/index.html?mode=result\" ></iframe>\n\n\n\n<h2 id=\"selection-sort\">Selection sort</h2>\n<p>Start from leftmost too.</p>\n<ol>\n<li>look for minimum player from current position to right</li>\n<li>swap minimum player with the player at current position</li>\n<li>move one position right</li>\n</ol>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/algorithm/selection-sort/index.html?mode=result\" ></iframe>\n\n\n\n<h2 id=\"insertion-sort\">Insertion sort</h2>\n<p>In most cases, this is the best of elementary sorts. It&#39;s about twice as fast as the bubble sort.<br>The steps is somewhat complicated than sorts above.Start from leftmost.</p>\n<ol>\n<li>partially sort left players</li>\n<li>choose the first unsorted player as marked player</li>\n<li>shift the players shorter than marked player to right</li>\n<li>insert marked player into the previous  position of first shifted player.</li>\n</ol>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/algorithm/insertion-sort/index.html?mode=result\" ></iframe>\n\n\n\n\n<h2 id=\"merge-sort\">Merge sort</h2>\n<p>The heart of the merge sort algorithm are the merging of two already-sorted arrays and recursion.<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Merge_sort_algorithm_diagram.svg/800px-Merge_sort_algorithm_diagram.svg.png\" alt=\"\"></p>\n<p>As shown in picture, main steps are:</p>\n<ol>\n<li>Recur to split numbers into 2 parts</li>\n<li>merge 2 parts</li>\n</ol>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/algorithm/merge-sort/index.html?mode=result\" ></iframe>\n\n\n\n<h2 id=\"shell-sort\">Shell sort</h2>\n<p>The name &quot;Shell sort&quot; is named for Donald Shell, who discovered it. It&#39;s based on <strong>insertion sort</strong>, but adds a new feature that dramatically improves the insertion sort&#39;s performance.  </p>\n<p>Main steps</p>\n<ol>\n<li>divide array into groups by interval(3 for example) and sort them continously until all items are divided and sorted.</li>\n<li>diminish the interval and continue to divide and sort until the interval becomes 1.</li>\n</ol>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/algorithm/shell-sort/index.html?mode=result\" ></iframe>\n\n\n\n\n<h2 id=\"quick-sort\">Quick sort</h2>\n<p>In the majority of situations, this is the fastest sort.</p>\n<ol>\n<li>choose a pivot(rightmost item)</li>\n<li>partition the array into left sub array(smaller keys) and right sub array(larger keys)</li>\n<li>recur step2 to left sub array and right sub array</li>\n</ol>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/algorithm/quick-sort/index.html?mode=result\" ></iframe>\n\n","createTime":"2019/01/15 22:54","categorySequence":["All","Technology","Algorithm","Sorting Algorithm"],"tags":[],"introduction":"[https://terry-su.github.io/BlogCDN/images/simpson-evolution.jpg] After learning common sorting algorithms,...","uniqueHtmlName":"demonstrate-sorting-algorithms-with-animated-demos","blogProps":{"createTime":"2019/01/15 22:54","comment":"13"}}]}
