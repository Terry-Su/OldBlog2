{"blogs":[{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/EN-Blogs/Technology/Javascript/Topic/A Deep Dive into Event Capture and Bubbling/A Deep Dive into Event Capture and Bubbling.md","relativeClientUrl":"blog/detail/a-deep-dive-into-event-capture-and-bubbling.html","relativeClientPropsUrl":"All/Technology/Javascript/Topic/A Deep Dive into Event Capture and Bubbling/props.json","name":"A Deep Dive into Event Capture and Bubbling","markedHtml":"<p>Suppose there&#39;s a div with a child div in it, and both of 2 divs have registered click events. If we click on the child div, which click event of 2 divs will fire first?<br><img src=\"https://terry-su.github.io/BlogCDN/images/blog-event-capture-bubbling/1.png\" alt=\"\"></p>\n<p>That question will take us to the topic today: Event Bubbling and Capture, in which the <strong>three phases of event propagation</strong> is the <strong>key</strong>.</p>\n<p>To solve the question above, we&#39;ve gotta know what event bubbling and capture are. And to know event bubbling and capture, we&#39;ve to know how the dom events of dom elements fire. </p>\n<p>As found in <a href=\"https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\">W3C-Event Flow</a>, if a dom event was triggered, its event objects will pass through 3 phases to dispatch themselves to event targets(dom elements):  </p>\n<p><img src=\"https://terry-su.github.io/BlogCDN/images/blog-event-capture-bubbling/2.png\" alt=\"\">    </p>\n<ol>\n<li><p>Capture phase<br>The event object passes through to the event target&#39;s ancestors from <code>Window</code> to the event target&#39;s parent.<br>If there&#39;re other available event targets whose capture attribute is set to <code>true</code>, then the event object will be dispatched to them.</p>\n</li>\n<li><p>Target phase<br>The event object arrives the event target.<br>If the event target&#39;s event type indicates the event doesn&#39;t bubble, then the event object will stop after this phase.</p>\n</li>\n<li><p>Bubbling Phase<br>(Reverse to capture phase)The event object passes through to the event target&#39;s ancestors from the event target&#39;s parent to <code>Window</code>.<br>If there&#39;re other available event targets whose bubbling attribute is set to <code>true</code>, then the event object will be dispatched to them.</p>\n</li>\n</ol>\n<p>Let&#39;s look back at the previous question, the answer can be clear.   </p>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/event-capture-bubbling/example/index.html?mode=result\" frameborder=\"0\"></iframe>\n\n\n<p>In this example, each box and its inner box both have registered click events. Once they were clicked, their borders will highlight one by one by the event propagation order. With the three phases of event propagation above, we could know how the 4 situations above happened.</p>\n<p>To make a summary: browser captures the event targets whose capture attribute is <code>true</code> by dom tree order first, then bubbles the event targets whose bubbling attribute is <code>true</code> by reverse dom tree order.</p>\n","createTime":"2018/10/12 16:22","categorySequence":["All","Technology","Javascript","Topic"],"tags":["javascript"],"introduction":"Suppose there's a div with a child div in it, and both of 2 divs have registered click events. If we...","uniqueHtmlName":"a-deep-dive-into-event-capture-and-bubbling","blogProps":{"createTime":"2018/10/12 16:22","tags":["javascript"],"comment":"12"}},{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/EN-Blogs/Technology/Javascript/Topic/Master JavaScript Implicit Type Conversion/Master JavaScript Implicit Type Conversion.md","relativeClientUrl":"blog/detail/master-javascript-implicit-type-conversion.html","relativeClientPropsUrl":"All/Technology/Javascript/Topic/Master JavaScript Implicit Type Conversion/props.json","name":"Master JavaScript Implicit Type Conversion","markedHtml":"<p><img src=\"https://terry-su.github.io/BlogCDN/images/photo/qing-cheng-shan.jpg\" alt=\"The Peak of Mountain QingCheng\">\n<em>The Peak of Mountain QingCheng</em></p>\n<p>Before starting this written-in-English article, I&#39;d like to thank   <a href=\"https://www.reddit.com/user/l3l_aze\">@l3l_aze</a> for pointing out my previous technology article&#39;s problems and giving me precious advice on how to write better in English. And after some time for preparation, I start writing articles in English again and will continue to write more.</p>\n<p>Implicit type conversion is one of JavaScript&#39;s most hot and important features. To master it completely, I&#39;ve searched lots of relevant articles, consulted the book &quot;JavaScript: The Definitive Guide, 6th&quot; and summarized those concepts, ideas, examples into this article.</p>\n<blockquote>\n<p>To learn a new knowledge point, we usually search and read a lot of relevant materials(blogs, StackOverflow, etc) online. However, to master it thoroughly, we&#39;d better look for its origin from the definitive material like MDN or a definitive book to ensure its correctness.</p>\n</blockquote>\n<h2 id=\"what-s-the-implicit-type-conversion-\">What&#39;s the implicit type conversion?</h2>\n<p>JavaScript is very flexible, it will convert the type of a value as needed automatically.\nFor example:</p>\n<pre><code class=\"language-js\">&#39;&#39; + 1 // &#39;1&#39;</code></pre>\n<h2 id=\"when-will-implicit-type-conversion-happen-\">When will implicit type conversion happen?</h2>\n<p>Here lists commonly used situations:</p>\n<p><strong>Expressions(with operators)</strong><br><em>Arithmetic</em>  </p>\n<ul>\n<li><code>+</code></li>\n</ul>\n<pre><code class=\"language-js\">/* unary +, converse x to number */\n+ x\n\n+ 1 // 1\n+ &#39;1&#39; // 1\n+ true // 1\n+ new Date() // (a numeric value)\n\n\n/* two operands */\na + b\n\n// 1. if either is an object, converse it to a primitive first\n{} + {} // &#39;[object object][object object]&#39;\n[] + [] // &#39;&#39;\n[] + new Date() // (A date string)\n\n// 2. if one is a string, converse the other to a string\n1 + &#39;&#39; // &#39;1&#39;\n&#39;&#39; + 1 // &#39;1&#39;\n&#39;&#39; + true // &#39;true&#39;\n\n// 3. otherwise, converse both to numbers\n1 + true // 2\ntrue + true // 2</code></pre>\n<ul>\n<li><code>-</code>, <code>*</code>, <code>/</code>, <code>++</code>, <code>--</code></li>\n</ul>\n<pre><code class=\"language-js\">/* Converse value or values to number */\n- &#39;1&#39; // -1\n[] - 1 // -1\n[] - {} // NaN</code></pre>\n<p><em>Relational</em></p>\n<ul>\n<li><code>==</code>, <code>!=</code></li>\n</ul>\n<pre><code class=\"language-js\">/* two operands */\na == b\n\n// 1. if one is `null` and the other is `undefined`, they are equal\nnull == undefined // true\n\n// 2. if one is a number and the other is a string, convert the string\n// to a number, compare again\n1 == &#39;1&#39; // true\n\n// 3. if either is boolean, convert it to a number, compare again\ntrue == 1 // true\nfalse == 0 // true\n\n// 4. if one is an object, and the other is a number or a string, \n// convert the object to a primitive, compare again\n[ 1 ] == 1 // true\n[ &#39;1&#39; ] == &#39;1&#39; // true</code></pre>\n<ul>\n<li><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></li>\n</ul>\n<pre><code class=\"language-js\">/* two operands */\na &gt; b\n\n// 1. if either is an object, convert it to a primitive, compare again\n[ 2 ] &gt; 1 // true\n\n// 2. if both are strings, compare them using alphabetical order\n&#39;b&#39; &gt; &#39;a&#39; // true\n\n// 3. if either is a number, convert one or two not number to number\n&#39;2&#39; &gt; 1 // true</code></pre>\n<ul>\n<li><code>in</code></li>\n</ul>\n<pre><code class=\"language-js\">/* if left operand isn&#39;t a string, convert it to a string  */\na in b\n\n&#39;1&#39; in { 1: &#39;&#39; } // true\n1 in { 1: &#39;a&#39; } // true\n1 in [ &#39;a&#39;, &#39;b&#39; ] // true</code></pre>\n<p><em>Logic</em>  </p>\n<ul>\n<li><code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>\n</ul>\n<pre><code class=\"language-js\">/* if either isn&#39;t booelan, convert it to a boolean value */\nBoolean( null || undefined || 0 || -0 || NaN || &#39;&#39; ) // false\nBoolean( 1 &amp;&amp; &#39;a&#39; &amp;&amp; {} &amp;&amp; [] &amp;&amp; [0] &amp;&amp; function(){} ) // true</code></pre>\n<p>Note that <strong>following</strong> <code>?:</code>, <code>if</code>, <code>else if</code>, <code>while</code>, <code>do/while</code> and <code>for</code> use the <strong>same implicit type conversion way</strong> as <code>&amp;&amp;</code>, <code>||</code> and <code>!</code>(Logic expression).</p>\n<p><em>Conditional</em></p>\n<ul>\n<li><code>?:</code></li>\n</ul>\n<p><strong>Statements</strong><br><em>Conditional</em>  </p>\n<ul>\n<li><code>if</code>, <code>else if</code></li>\n</ul>\n<p><em>Loop</em></p>\n<ul>\n<li><code>while</code>, <code>do/while</code>, <code>for</code></li>\n</ul>\n<h2 id=\"how-about-explicit-type-conversion\">How about explicit type conversion</h2>\n<p>Explicit type conversion makes the type conversion codes clear.<br>Although there&#39;re many ways to perform an explicit type conversion, such as <code>toString()</code> and <code>parseInt()</code>, it&#39;s recommended to use <code>Boolean()</code>, <code>Number()</code>, <code>String()</code> or <code>Object()</code> functions.</p>\n<pre><code class=\"language-js\">Boolean( 1 ) // true\nBoolean( 0 ) // false\n\nNumber( &#39;1&#39; ) // 1\n\nString( 1 ) // &#39;1&#39;\n\nObject( 1 ) // new Number(1)</code></pre>\n<h2 id=\"common-javascript-type-conversion\">Common JavaScript Type Conversion</h2>\n<p>The following reference table, from the book &quot;JavaScript: The Definitive Guide, 6th&quot;, is especially convenient to look up common type conversion in JavaScript</p>\n<p><img src=\"https://terry-su.github.io/BlogCDN/images/javascript-type-conversion.png\" alt=\"Little Bar\">\n<em>&quot;JavaScript-The Definitive Guide 6th&quot; 3.8.0</em></p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Implicit type conversion can be very useful sometimes, simplifying our codes, for example. But we&#39;d better also pay attention to the potential risk that conversed value could be unexpected if someone wasn&#39;t familiar with the rules of implicit type conversion enough. To avoid this, use explicit type conversion instead.</p>\n","createTime":"2018/10/09 14:53","categorySequence":["All","Technology","Javascript","Topic"],"tags":["javascript"],"introduction":"The Peak of Mountain QingCheng [https://terry-su.github.io/BlogCDN/images/photo/qing-cheng-shan.jpg]...","uniqueHtmlName":"master-javascript-implicit-type-conversion","blogProps":{"createTime":"2018/10/09 14:53","tags":["javascript"],"comment":"11"}},{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/EN-Blogs/Technology/Javascript/Topic/Geometry-Algorithms-in-Javascript/Geometry Algorithm in Javascript.md","relativeClientUrl":"blog/detail/geometry-algorithms-in-javascript.html","relativeClientPropsUrl":"All/Technology/Javascript/Topic/Geometry-Algorithms-in-Javascript/props.json","name":"Geometry Algorithm in Javascript","markedHtml":"<p>Recently, I&#39;ve been learning geo algorithms for developing a geometry library. However, I found that the materials of 2d geometry algorithms on the internet ara <strong>complicated</strong> and <strong>messy</strong> since I only want to find several basic and commonly used algorithms. Here, I will try my best to make 2d geometry algorithms below <strong>easy</strong> to be understood and used. </p>\n<p>By the way, you may not be necessary to read this article paragraph by paragraph, you can just read any topic which you prefer. Here we go!</p>\n<h3 id=\"transformation\">Transformation</h3>\n<h5 id=\"translation\">Translation</h5>\n<p><img src=\"https://www.tutorialspoint.com/computer_graphics/images/translation.jpg\" alt=\"Image\"><br>Suppose we move point&#39;s position from <code>(x, y)</code> to <code>(x&#39;, y&#39;)</code>:</p>\n<pre><code class=\"language-math\">x &#39; = x + t _ x</code></pre>\n<pre><code class=\"language-math\">y &#39; = y + t _ y</code></pre>\n<h5 id=\"scale\">Scale</h5>\n<p><img src=\"https://www.tutorialspoint.com/computer_graphics/images/before_scaling.jpg\" alt=\"Image\"><br><img src=\"https://www.tutorialspoint.com/computer_graphics/images/after_scaling.jpg\" alt=\"Image\"><br>Suppose we scale the <code>x</code> of point by <code>sx</code> times and the <code>y</code> of point by <code>sy</code> times, then:</p>\n<pre><code class=\"language-math\">x &#39; = s _ x * x</code></pre>\n<pre><code class=\"language-math\">y &#39; = s _ y * y</code></pre>\n<blockquote>\n<p><strong>Scale point based on a center point <code>(xc, yc)</code></strong></p>\n<pre><code class=\"language-math\">x &#39; = s _ x * x - ( s _ x * x _ c - x _ c )</code></pre>\n<pre><code class=\"language-math\">y &#39; = s _ y * y - ( s _ y * y _ c - y _ c )</code></pre>\n</blockquote>\n<h5 id=\"rotation\">Rotation</h5>\n<p><img src=\"https://www.tutorialspoint.com/computer_graphics/images/rotation.jpg\" alt=\"Image\"><br>Suppose we rotate <code>OP</code> to <code>OP&#39;</code>.<br>Because:</p>\n<pre><code class=\"language-math\">x = r \\cdot cos \\varphi</code></pre>\n<pre><code class=\"language-math\">y = r \\cdot sin \\varphi</code></pre>\n<p>Then:</p>\n<pre><code class=\"language-math\">x&#39; = r \\cdot cos ( \\varphi + \\theta ) = r \\cdot ( cos \\varphi \\cdot cos \\theta - sin \\varphi \\cdot sin \\theta ) = x \\cdot cos \\theta - y \\cdot sin \\theta</code></pre>\n<pre><code class=\"language-math\">y&#39; = r \\cdot sin ( \\varphi + \\theta ) = r \\cdot ( sin \\varphi \\cdot cos \\theta + cos \\varphi \\cdot sin \\theta ) = x \\cdot sin \\theta + y \\cdot cos \\theta</code></pre>\n<blockquote>\n<p><strong>Rotate point based on a center point <code>(xc, yc)</code></strong></p>\n<pre><code class=\"language-math\">x&#39; =  x \\cdot cos \\theta - y \\cdot sin \\theta + xc</code></pre>\n<pre><code class=\"language-math\">y&#39; = x \\cdot sin \\theta + y \\cdot cos \\theta + yc</code></pre>\n</blockquote>\n<h3 id=\"point-in-polygon\">Point in polygon</h3>\n<p>In fact, there&#39;re two well-known &quot;point in polygon&quot; algorithms: <strong>winding number</strong> and <strong>crossing number</strong>, however, I will only talk about <strong>winding number</strong>, here are reasons:</p>\n<table>\n<thead>\n<tr>\n<th>/</th>\n<th>Rule</th>\n<th>Suitable Scene</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Winding</strong> number</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Nonzero-rule\">Nonezero-rule</a></td>\n<td>All polygons</td>\n</tr>\n<tr>\n<td>Crossing Number</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\">Even-odd rule</a></td>\n<td>Polygons with simple curves</td>\n</tr>\n</tbody></table>\n<p>As we can see above, <strong>crossing number</strong> is not suitable for all polygons.</p>\n<h5 id=\"winding-number\">Winding number</h5>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/8/8f/Winding_Number_Around_Point.svg\" alt=\"Image\"><br>Draw an <strong>infinite ray</strong> from <code>P</code> crossing polygon, then count each <strong>vertex</strong>, here&#39;s the key: suppose we start at any point on polygon path and end at the same point to draw polygon <strong>counterclockwise</strong>, if the <code>vector</code> intersected the <strong>special vertex</strong>(intersected by infinite ray and polygon) is <strong>upward</strong>, <code>wn</code> <strong>adds <code>1</code></strong>, otherwise if the track intersected vertex is <strong>downward</strong>, <code>wn</code> <strong>subtracts <code>1</code></strong>. If the <code>wn</code> of <code>P</code> is not <code>0</code>, then <code>P</code> is <strong>inside</strong> of polygon, otherwise <code>P</code> is <strong>outside</strong>.<br>Main javascript(typescript) <strong>codes</strong>(If you want to see whole detail code, visit <a href=\"https://github.com/Terry-Su/Geometry-Algorithm/blob/master/src/core/calcPointInPolygon.ts\">here</a>):</p>\n<pre><code class=\"language-ts\">/**\n * Check if point P is inside of polygon with winding number algorithm\n * Algorithm: http://geomalgorithms.com/a03-_inclusion.html\n * @param {Point2D} P point P\n * @param {Point2D[]} polygonVertices vertices of polygon path in clockwise or counterclockwise order\n */\nfunction pointInPolygonWindingNumber(\n  P: Point2D,\n  polygonVertices: Point2D[]\n) {\n  /**\n   * Winding nunebr\n   */\n  let wn = 0\n\n  const points: Point2D[] = polygonVertices\n\n  for ( let i: number = 0; i &lt; points.length - 1; i++ ) {\n    const V0: Point2D = points[ i ]\n    const V1: Point2D = points[ i + 1 ]\n\n    const { x: x0, y: y0 }: Point2D = V0\n    const { x: x1, y: y1 }: Point2D = V1\n    const { x: xp, y: yp }: Point2D = P\n\n    /**\n     * Upward\n     */\n    if ( y0 &lt;= yp &amp;&amp; y1 &gt; yp &amp;&amp; isLeft( V0, V1, P ) ) {\n      wn = wn + 1\n    }\n    /**\n     * Downward\n     */\n    if ( y0 &gt; yp &amp;&amp; y1 &lt;= yp &amp;&amp; isRight( V0, V1, P ) ) {\n      wn = wn - 1\n    }\n  }\n\n  const pointOnPolygonPath: boolean = isPointOnPolygonPath( P, points )\n  const res: boolean = pointOnPolygonPath || wn !== 0\n\n  return res\n}</code></pre>\n<h3 id=\"matrix\">Matrix</h3>\n<p>I&#39;m curious about matrices too, not only when learning geometry algorithms. Matrix, which like an magician, transforms geometry with its particular formula.</p>\n<h5 id=\"translation\">Translation</h5>\n<pre><code class=\"language-math\">\\begin{bmatrix}\n   x&#39; \\\\\n   y&#39;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n   x \\\\\n   y\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n   tx \\\\\n   ty\n\\end{bmatrix}</code></pre>\n<h5 id=\"scale\">Scale</h5>\n<pre><code class=\"language-math\">\\begin{bmatrix}\n   x&#39; \\\\\n   y&#39;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n   S _ x &amp; 0 \\\\\n   0 &amp; S _ y\n\\end{bmatrix}\n\\begin{bmatrix}\n   x \\\\\n   y\n\\end{bmatrix}</code></pre>\n<h5 id=\"rotation\">Rotation</h5>\n<pre><code class=\"language-math\">\\begin{bmatrix}\n   x&#39; \\\\\n   y&#39;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  cos \\theta &amp; -sin \\theta \\\\\n  sin \\theta &amp; cos \\theta\n\\end{bmatrix}\n\\begin{bmatrix}\n   x \\\\\n   y\n\\end{bmatrix}</code></pre>\n<h3 id=\"formulas\">Formulas</h3>\n<p>There are plenty of geometry algorithms, however, I only list several alogorithms which are <strong>frequently used</strong> above. Maybe, I say maybe, I will add new algorithms in this blog if I find new commonly used algorithm in the future. \nNevertheless, I&#39;ll still list some <strong>practical</strong> formulas which can be used for geometry calculation.</p>\n<h5 id=\"the-cosine-law\">The Cosine Law</h5>\n<p>Suppose there are vector v and w</p>\n<pre><code class=\"language-math\">| v \\pm w | ^ 2 = | v | ^ 2 \\pm 2 | v | | w | cos( \\theta ) + | w | ^ 2</code></pre>\n<h5 id=\"the-dot-product\">The Dot Product</h5>\n<p>One vector multiply the other vector:</p>\n<pre><code class=\"language-math\">v \\cdot w = | v | | w | cos ( \\theta )</code></pre>\n<h5 id=\"the-2d-perp-product\">The 2D Perp Product</h5>\n<pre><code class=\"language-math\">v \\perp w = | v | | w | sin ( \\theta )</code></pre>\n<h5 id=\"computing-area\">Computing area</h5>\n<ul>\n<li><p>Parallelogram</p>\n<pre><code class=\"language-math\">A ( \\Box ) = | v \\perp w | </code></pre>\n<pre><code class=\"language-math\">  = |v| |w| sin( \\theta )</code></pre>\n</li>\n<li><p>Triangles</p>\n<pre><code class=\"language-math\">A ( \\vartriangle ) = | v \\perp w | / 2t</code></pre>\n<pre><code class=\"language-math\">  = |v| |w| sin( \\theta ) / 2</code></pre>\n</li>\n</ul>\n<h5 id=\"lines-formula\">Lines formula</h5>\n<ul>\n<li><p>Type-Parametric</p>\n<pre><code class=\"language-math\">P(t) = P _ 0 + t v _ L </code></pre>\n</li>\n<li><p>Line equations</p>\n<pre><code class=\"language-math\">P ( t ) = P _ 0 + t v _ L </code></pre>\n<pre><code class=\"language-math\">  = P _ 0 + t ( P _ 1 - P _ 0 )</code></pre>\n<pre><code class=\"language-math\">  = ( 1 - t ) P _ 0 + t P _ 1</code></pre>\n<pre><code class=\"language-math\">  = ( x _ 0 + t cos \\theta , y _ 0 + t sin \\theta ) </code></pre>\n</li>\n</ul>\n<p>It&#39;s easy to learn and use a geometry library, however, it&#39;s <strong>limited</strong> when we want to build a <strong>large</strong> or complex even just <strong>a little complex project</strong>. Grasping geometry algorithms will make it possible for us to create <strong>flexible</strong> and <strong>large</strong> geometry projects.</p>\n<h3 id=\"reference\">Reference</h3>\n<p>[0] <strong>Transformation:</strong> <a href=\"https://www.tutorialspoint.com/computer_graphics/2d_transformation.htm\">https://www.tutorialspoint.com/computer_graphics/2d_transformation.htm</a><br>[1] <strong>Point in polygon1:</strong> <a href=\"https://en.wikipedia.org/wiki/Point_in_polygon\">https://en.wikipedia.org/wiki/Point_in_polygon</a><br>[2] <strong>Point in polygon2:</strong> <a href=\"http://geomalgorithms.com/a03-_inclusion.html\">http://geomalgorithms.com/a03-_inclusion.html</a><br>[3] <strong>Nonezero-rule:</strong> <a href=\"https://en.wikipedia.org/wiki/Nonzero-rule\">https://en.wikipedia.org/wiki/Nonzero-rule</a><br>[4] <strong>Even-odd rule:</strong> <a href=\"https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\">https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule</a><br>[5] <strong>Computing area:</strong> <a href=\"http://geomalgorithms.com/a01-_area.html\">http://geomalgorithms.com/a01-_area.html</a><br>[6] <strong>Line formula:</strong> <a href=\"http://geomalgorithms.com/a02-_lines.html\">http://geomalgorithms.com/a02-_lines.html</a>  </p>\n","createTime":"2018/02/12 10:07","categorySequence":["All","Technology","Javascript","Topic"],"tags":["geometry","javascript"],"introduction":"Recently, I've been learning geo algorithms for developing a geometry library. However, I found that...","uniqueHtmlName":"geometry-algorithms-in-javascript","blogProps":{"createTime":"2018/02/12 10:07","tags":["geometry","javascript"],"comment":"5"}}]}
