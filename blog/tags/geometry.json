{"blogs":[{"relativeClientUrl":"blog/detail/geometry-algorithms-in-javascript.html","name":"Geometry Algorithm in Javascript","markedHtml":"<p>Recently, I&#39;ve been learning geo algorithms for developing a geometry library. However, I found that the materials of 2d geometry algorithms on the internet ara <strong>complicated</strong> and <strong>messy</strong> since I only want to find several basic and commonly used algorithms. Here, I will try my best to make 2d geometry algorithms below <strong>easy</strong> to be understood and used. </p>\n<p>By the way, you may not be necessary to read this article paragraph by paragraph, you can just read any topic which you prefer. Here we go!</p>\n<h3 id=\"transformation\">Transformation</h3>\n<h5 id=\"translation\">Translation</h5>\n<p><img src=\"https://www.tutorialspoint.com/computer_graphics/images/translation.jpg\" alt=\"Image\"><br>Suppose we move point&#39;s position from <code>(x, y)</code> to <code>(x&#39;, y&#39;)</code>:</p>\n<pre><code class=\"language-math\">x &#39; = x + t _ x</code></pre>\n<pre><code class=\"language-math\">y &#39; = y + t _ y</code></pre>\n<h5 id=\"scale\">Scale</h5>\n<p><img src=\"https://www.tutorialspoint.com/computer_graphics/images/before_scaling.jpg\" alt=\"Image\"><br><img src=\"https://www.tutorialspoint.com/computer_graphics/images/after_scaling.jpg\" alt=\"Image\"><br>Suppose we scale the <code>x</code> of point by <code>sx</code> times and the <code>y</code> of point by <code>sy</code> times, then:</p>\n<pre><code class=\"language-math\">x &#39; = s _ x * x</code></pre>\n<pre><code class=\"language-math\">y &#39; = s _ y * y</code></pre>\n<blockquote>\n<p><strong>Scale point based on a center point <code>(xc, yc)</code></strong></p>\n<pre><code class=\"language-math\">x &#39; = s _ x * x - ( s _ x * x _ c - x _ c )</code></pre>\n<pre><code class=\"language-math\">y &#39; = s _ y * y - ( s _ y * y _ c - y _ c )</code></pre>\n</blockquote>\n<h5 id=\"rotation\">Rotation</h5>\n<p><img src=\"https://www.tutorialspoint.com/computer_graphics/images/rotation.jpg\" alt=\"Image\"><br>Suppose we rotate <code>OP</code> to <code>OP&#39;</code>.<br>Because:</p>\n<pre><code class=\"language-math\">x = r \\cdot cos \\varphi</code></pre>\n<pre><code class=\"language-math\">y = r \\cdot sin \\varphi</code></pre>\n<p>Then:</p>\n<pre><code class=\"language-math\">x&#39; = r \\cdot cos ( \\varphi + \\theta ) = r \\cdot ( cos \\varphi \\cdot cos \\theta - sin \\varphi \\cdot sin \\theta ) = x \\cdot cos \\theta - y \\cdot sin \\theta</code></pre>\n<pre><code class=\"language-math\">y&#39; = r \\cdot sin ( \\varphi + \\theta ) = r \\cdot ( sin \\varphi \\cdot cos \\theta + cos \\varphi \\cdot sin \\theta ) = x \\cdot sin \\theta + y \\cdot cos \\theta</code></pre>\n<blockquote>\n<p><strong>Rotate point based on a center point <code>(xc, yc)</code></strong></p>\n<pre><code class=\"language-math\">x&#39; =  x \\cdot cos \\theta - y \\cdot sin \\theta + xc</code></pre>\n<pre><code class=\"language-math\">y&#39; = x \\cdot sin \\theta + y \\cdot cos \\theta + yc</code></pre>\n</blockquote>\n<h3 id=\"point-in-polygon\">Point in polygon</h3>\n<p>In fact, there&#39;re two well-known &quot;point in polygon&quot; algorithms: <strong>winding number</strong> and <strong>crossing number</strong>, however, I will only talk about <strong>winding number</strong>, here are reasons:</p>\n<table>\n<thead>\n<tr>\n<th>/</th>\n<th>Rule</th>\n<th>Suitable Scene</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Winding</strong> number</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Nonzero-rule\">Nonezero-rule</a></td>\n<td>All polygons</td>\n</tr>\n<tr>\n<td>Crossing Number</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\">Even-odd rule</a></td>\n<td>Polygons with simple curves</td>\n</tr>\n</tbody></table>\n<p>As we can see above, <strong>crossing number</strong> is not suitable for all polygons.</p>\n<h5 id=\"winding-number\">Winding number</h5>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/8/8f/Winding_Number_Around_Point.svg\" alt=\"Image\"><br>Draw an <strong>infinite ray</strong> from <code>P</code> crossing polygon, then count each <strong>vertex</strong>, here&#39;s the key: suppose we start at any point on polygon path and end at the same point to draw polygon <strong>counterclockwise</strong>, if the <code>vector</code> intersected the <strong>special vertex</strong>(intersected by infinite ray and polygon) is <strong>upward</strong>, <code>wn</code> <strong>adds <code>1</code></strong>, otherwise if the track intersected vertex is <strong>downward</strong>, <code>wn</code> <strong>subtracts <code>1</code></strong>. If the <code>wn</code> of <code>P</code> is not <code>0</code>, then <code>P</code> is <strong>inside</strong> of polygon, otherwise <code>P</code> is <strong>outside</strong>.<br>Main javascript(typescript) <strong>codes</strong>(If you want to see whole detail code, visit <a href=\"https://github.com/Terry-Su/Geometry-Algorithm/blob/master/src/core/calcPointInPolygon.ts\">here</a>):</p>\n<pre><code class=\"language-ts\">/**\n * Check if point P is inside of polygon with winding number algorithm\n * Algorithm: http://geomalgorithms.com/a03-_inclusion.html\n * @param {Point2D} P point P\n * @param {Point2D[]} polygonVertices vertices of polygon path in clockwise or counterclockwise order\n */\nfunction pointInPolygonWindingNumber(\n  P: Point2D,\n  polygonVertices: Point2D[]\n) {\n  /**\n   * Winding nunebr\n   */\n  let wn = 0\n\n  const points: Point2D[] = polygonVertices\n\n  for ( let i: number = 0; i &lt; points.length - 1; i++ ) {\n    const V0: Point2D = points[ i ]\n    const V1: Point2D = points[ i + 1 ]\n\n    const { x: x0, y: y0 }: Point2D = V0\n    const { x: x1, y: y1 }: Point2D = V1\n    const { x: xp, y: yp }: Point2D = P\n\n    /**\n     * Upward\n     */\n    if ( y0 &lt;= yp &amp;&amp; y1 &gt; yp &amp;&amp; isLeft( V0, V1, P ) ) {\n      wn = wn + 1\n    }\n    /**\n     * Downward\n     */\n    if ( y0 &gt; yp &amp;&amp; y1 &lt;= yp &amp;&amp; isRight( V0, V1, P ) ) {\n      wn = wn - 1\n    }\n  }\n\n  const pointOnPolygonPath: boolean = isPointOnPolygonPath( P, points )\n  const res: boolean = pointOnPolygonPath || wn !== 0\n\n  return res\n}</code></pre>\n<h3 id=\"matrix\">Matrix</h3>\n<p>I&#39;m curious about matrices too, not only when learning geometry algorithms. Matrix, which like an magician, transforms geometry with its particular formula.</p>\n<h5 id=\"translation\">Translation</h5>\n<pre><code class=\"language-math\">\\begin{bmatrix}\n   x&#39; \\\\\n   y&#39;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n   x \\\\\n   y\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n   tx \\\\\n   ty\n\\end{bmatrix}</code></pre>\n<h5 id=\"scale\">Scale</h5>\n<pre><code class=\"language-math\">\\begin{bmatrix}\n   x&#39; \\\\\n   y&#39;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n   S _ x &amp; 0 \\\\\n   0 &amp; S _ y\n\\end{bmatrix}\n\\begin{bmatrix}\n   x \\\\\n   y\n\\end{bmatrix}</code></pre>\n<h5 id=\"rotation\">Rotation</h5>\n<pre><code class=\"language-math\">\\begin{bmatrix}\n   x&#39; \\\\\n   y&#39;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  cos \\theta &amp; -sin \\theta \\\\\n  sin \\theta &amp; cos \\theta\n\\end{bmatrix}\n\\begin{bmatrix}\n   x \\\\\n   y\n\\end{bmatrix}</code></pre>\n<h3 id=\"formulas\">Formulas</h3>\n<p>There are plenty of geometry algorithms, however, I only list several alogorithms which are <strong>frequently used</strong> above. Maybe, I say maybe, I will add new algorithms in this blog if I find new commonly used algorithm in the future. \nNevertheless, I&#39;ll still list some <strong>practical</strong> formulas which can be used for geometry calculation.</p>\n<h5 id=\"the-cosine-law\">The Cosine Law</h5>\n<p>Suppose there are vector v and w</p>\n<pre><code class=\"language-math\">| v \\pm w | ^ 2 = | v | ^ 2 \\pm 2 | v | | w | cos( \\theta ) + | w | ^ 2</code></pre>\n<h5 id=\"the-dot-product\">The Dot Product</h5>\n<p>One vector multiply the other vector:</p>\n<pre><code class=\"language-math\">v \\cdot w = | v | | w | cos ( \\theta )</code></pre>\n<h5 id=\"the-2d-perp-product\">The 2D Perp Product</h5>\n<pre><code class=\"language-math\">v \\perp w = | v | | w | sin ( \\theta )</code></pre>\n<h5 id=\"computing-area\">Computing area</h5>\n<ul>\n<li><p>Parallelogram</p>\n<pre><code class=\"language-math\">A ( \\Box ) = | v \\perp w | </code></pre>\n<pre><code class=\"language-math\">  = |v| |w| sin( \\theta )</code></pre>\n</li>\n<li><p>Triangles</p>\n<pre><code class=\"language-math\">A ( \\vartriangle ) = | v \\perp w | / 2t</code></pre>\n<pre><code class=\"language-math\">  = |v| |w| sin( \\theta ) / 2</code></pre>\n</li>\n</ul>\n<h5 id=\"lines-formula\">Lines formula</h5>\n<ul>\n<li><p>Type-Parametric</p>\n<pre><code class=\"language-math\">P(t) = P _ 0 + t v _ L </code></pre>\n</li>\n<li><p>Line equations</p>\n<pre><code class=\"language-math\">P ( t ) = P _ 0 + t v _ L </code></pre>\n<pre><code class=\"language-math\">  = P _ 0 + t ( P _ 1 - P _ 0 )</code></pre>\n<pre><code class=\"language-math\">  = ( 1 - t ) P _ 0 + t P _ 1</code></pre>\n<pre><code class=\"language-math\">  = ( x _ 0 + t cos \\theta , y _ 0 + t sin \\theta ) </code></pre>\n</li>\n</ul>\n<p>It&#39;s easy to learn and use a geometry library, however, it&#39;s <strong>limited</strong> when we want to build a <strong>large</strong> or complex even just <strong>a little complex project</strong>. Grasping geometry algorithms will make it possible for us to create <strong>flexible</strong> and <strong>large</strong> geometry projects.</p>\n<h3 id=\"reference\">Reference</h3>\n<p>[0] <strong>Transformation:</strong> <a href=\"https://www.tutorialspoint.com/computer_graphics/2d_transformation.htm\">https://www.tutorialspoint.com/computer_graphics/2d_transformation.htm</a><br>[1] <strong>Point in polygon1:</strong> <a href=\"https://en.wikipedia.org/wiki/Point_in_polygon\">https://en.wikipedia.org/wiki/Point_in_polygon</a><br>[2] <strong>Point in polygon2:</strong> <a href=\"http://geomalgorithms.com/a03-_inclusion.html\">http://geomalgorithms.com/a03-_inclusion.html</a><br>[3] <strong>Nonezero-rule:</strong> <a href=\"https://en.wikipedia.org/wiki/Nonzero-rule\">https://en.wikipedia.org/wiki/Nonzero-rule</a><br>[4] <strong>Even-odd rule:</strong> <a href=\"https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\">https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule</a><br>[5] <strong>Computing area:</strong> <a href=\"http://geomalgorithms.com/a01-_area.html\">http://geomalgorithms.com/a01-_area.html</a><br>[6] <strong>Line formula:</strong> <a href=\"http://geomalgorithms.com/a02-_lines.html\">http://geomalgorithms.com/a02-_lines.html</a>  </p>\n","createTime":"2018/02/12 10:07","categorySequence":["All","Technology","Javascript","Topic"],"introduction":"Recently, I've been learning geo algorithms for developing a geometry library. However, I found that...","uniqueHtmlName":"geometry-algorithms-in-javascript","blogProps":{"createTime":"2018/02/12 10:07","tags":["geometry","javascript"],"comment":"5"}}]}
