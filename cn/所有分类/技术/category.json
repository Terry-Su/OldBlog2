{"blogs":[{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/CN-Blogs/技术/Redux/reveal-redux-react-redux-mask/index.md","relativeClientUrl":"detail/reveal-redux-react-redux-mask.html","relativeClientPropsUrl":"所有分类/技术/Redux/reveal-redux-react-redux-mask/props.json","name":"揭开redux，react-redux的神秘面纱","markedHtml":"<p>16年开始使用react-redux,迄今也已两年多。这时候再来阅读和读懂redux/react-redux源码，虽已没有当初的新鲜感，但依然觉得略有收获。把要点简单写下来，一方面供感兴趣的读者参考，另一方面也是自己做下总结。</p>\n<h2 id=\"redux\">redux</h2>\n<p>react-redux最核心的内容就是redux。内带redux，react-redux只提供了几个API来关联redux与react的组件以及react state的更新。</p>\n<p>首先，看下如何使用redux。 redux老司机可以直接滑动滚轮至下一章。<br>简单来说，redux有三个概念，action, reducer 和 dispatch。 action和dispatch比较好理解：动作指令和提交动作指令方法。而reducer，个人在字面上没有理解，但抽象层面上可以理解为用来生成state的函数。用一个简单案例体现这三个概念：</p>\n<pre><code class=\"language-js\">// action\nconst INCREMENT = { type: &#39;INCREMENT&#39; }\n\n// reducer\nfunction count( state = 0, action ) {\n    switch( action.type ) {\n        case &#39;INCREMENT&#39;:\n            return state + 1\n        default: \n          return state\n    }\n}\n\n// dispatch\n// 此处开始使用redux\nconst store = redux.createStore( count )\nconsole.log( store.getState() )  // 0\nstore.dispatch( INCREMENT )\nconsole.log( store.getState() ) // 1</code></pre>\n<p>接下来说说redux中的两大模块：</p>\n<ul>\n<li><code>store</code>对象</li>\n<li>中间件</li>\n</ul>\n<h2 id=\"store-\">store对象</h2>\n<p>API<code>createStore</code>会创建了一个<code>store</code>对象,创建的过程中它主要做了下面两件事：</p>\n<ol>\n<li>初始化state</li>\n<li>暴露相关接口：<code>getState()</code>, <code>dispatch( action )</code>, <code>subscribe( listener )</code>等。其中<code>getState()</code>用来获取store中的实时state, <code>dispatch(action)</code>根据传入的action更新state, <code>subscribe( listener)</code>可以监听state的变化。</li>\n</ol>\n<h2 id=\"-\">中间件</h2>\n<p>中间件可以用来debug或提交异步动作指令. 在初始化store的时候，我们通过<code>createStore( reducer, state, applyMiddleware( middleware1, middleware2 ) )</code>添加多个中间件。<br>为了实现多个中间件，redux专门引入了函数式编程的<code>compose()</code>方法，简单来说，<code>compose</code>将多层函数调用的写法变得优雅：</p>\n<pre><code class=\"language-js\">// 未使用compose方法\na( b( c( &#39;d&#39; ) ) )\n\n// 用compose方法\ncompose( a, b, c )(&#39;d&#39;)</code></pre>\n<p>而中间件的写法比较奇特，是多级函数，在阅读源码的时候有点绕。显然中间件的写法还可以优化，尽管现在的写法方便在源码中使用，但对redux用户来说稍显复杂，可以用单层函数。</p>\n<pre><code class=\"language-js\">function logMiddleware({ getState  }) {\n    return nextDispatch =&gt; action =&gt; {\n        console.log( &#39;before dispatch&#39;, getState() )\n        const res = nextDispatch( action )\n        console.log( &#39;after dispatch&#39;, getState() )\n        return res\n    }\n}</code></pre>\n<h2 id=\"react-redux\">react-redux</h2>\n<p>了解了redux运作原理，就可以知道react-redux的大部分使用场景是如何运作。react-redux提供了几个API将redux与react相互关联。</p>\n<p>基于上一个案例展示react-redux的用法：</p>\n<pre><code class=\"language-jsx\">// action\nconst increment = () =&gt; ({ type: &#39;INCREMENT&#39; })\n\n// reducer\nfunction count( state = 0, action ) {\n    switch( action.type ) {\n        case &#39;INCREMENT&#39;:\n            return state + 1\n        default: \n          return state\n    }\n}\n\n// redux\nconst store = Redux.createStore( count )\n\n// react-redux\nconst { Provider, connect } = ReactRedux\nconst mapStateToProps = state =&gt; ( { count: state } )\nconst mapDispatchToProps = dispatch =&gt; ( { increment : () =&gt; dispatch( increment() ) } )\nconst App = connect( mapStateToProps, mapDispatchToProps )( class extends React.Component {\n  onClick = () =&gt; {\n   this.props.increment()\n  }  \n  render() {\n        return &lt;div&gt;\n          &lt;p&gt;Count: { this.props.count }&lt;/p&gt;\n          &lt;button onClick={ this.onClick }&gt;+&lt;/button&gt;\n        &lt;/div&gt;\n    }\n} )\n\nReactDOM.render( &lt;Provider store={ store }&gt;\n    &lt;App /&gt;\n&lt;/Provider&gt;, document.getElementById( &#39;app&#39; ) )</code></pre>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/react-redux/demo/index.html?mode=result\"></iframe>\n\n\n\n<p>react-redux提供最常用的两个API是：</p>\n<ul>\n<li><code>Provider</code></li>\n<li><code>connect</code></li>\n</ul>\n<h2 id=\"provider\"><code>Provider</code></h2>\n<p>Provider本质上是一个react组件，通过react的<a href=\"https://reactjs.org/docs/legacy-context.html#how-to-use-context\">context api</a>(使一个组件可以跨多级组件传递props)挂载redux store中的state，并且当组件初始化后开始监听state。\n当监听到state改变，Provider会重新<code>setState</code>在context上的<code>storeState</code>，简要实现代码如下：</p>\n<pre><code class=\"language-jsx\">class Provider extends Component {\n    constructor(props) {\n      super(props)\n\n      const { store } = props\n\n      this.state = {\n        storeState: Redux.store.getState(),\n      }\n    }\n\n    componentDidMount() {\n      this.subscribe()\n    }\n\n    subscribe() {\n        const { store } = this.props\n        store.subscribe(() =&gt; {\n          const newStoreState = store.getState()\n          this.setState(providerState =&gt; {\n            return { storeState: newStoreState }\n          })\n        })\n    }\n    render() {\n        const Context = React.createContext(null)\n        &lt;Context.Provider value={this.state}&gt;\n            {this.props.children}\n        &lt;/Context.Provider&gt;\n    }\n}</code></pre>\n<h2 id=\"connect-\"><code>connect()</code></h2>\n<p><code>connect</code>方法通过<code>connectHOC</code>（HOC: react高阶组件）将部分或所有state以及提交动作指令方法赋值给react组件的props。</p>\n<h2 id=\"-\">小结</h2>\n<p>写react不用redux就像写代码不用git, 我们需要用redux来更好地管理react应用中的state。了解redux/react-redux的运作原理会消除我们在使用redux开发时的未知和疑惑，并且在脑中有一个完整的代码执行回路，让开发流程变得透明，直观。</p>\n","createTime":"2018/12/18 9:27","categorySequence":["所有分类","技术","Redux"],"tags":[],"introduction":"16年开始使用react-redux,迄今也已两年多。这时候再来阅读和读懂redux/react-redux源码，虽已没有当初的新鲜感，但依然觉得略有收获。把要点简单写下来，一方面供感兴趣的读者参考，另一方面也是自己做下总结。...","uniqueHtmlName":"reveal-redux-react-redux-mask","blogProps":{"name":"揭开redux，react-redux的神秘面纱","createTime":"2018/12/18 9:27","comment":"4"}},{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/CN-Blogs/技术/JavaScript/专题/throttle/index.md","relativeClientUrl":"detail/throttle.html","relativeClientPropsUrl":"所有分类/技术/JavaScript/专题/throttle/props.json","name":"节流 - 理解，实践与实现","markedHtml":"<p>节流(分流)，与防抖（去抖）实现原理相似。本文主要讨论节流，镜像文章：<a href=\"/cn/detail/debounce.html\">防抖 - 理解，实践与实现</a>。分开讨论防抖和节流，主要是为了让一些还不太了解节流防抖的读者能够有针对性地，逐一掌握它们。<br>如何用代码实现节流也是一个要点。本文采用循序渐进地方式，先绘制一个案例的流程图，再根据流程图的逻辑编写节流功能代码。</p>\n<h2 id=\"-\">节流案例</h2>\n<br/>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/throttle/mousemove/index.html?mode=result\" ></iframe>\n\n<p>当鼠标移动时，mousemove事件频繁被触发。上方为未节流模式，每一次mousemove触发都会绘制一个圆点。而下方为节流模式，尽管mosuemove在鼠标移动时被多次触发，但只有在限定时间间隔才会绘制圆点。</p>\n<h2 id=\"-\">理解和实现节流</h2>\n<p>通过上方案例，可以基本了解节流的作用: 频繁触发的事件，事件处理函数在一定的时间间隔内只执行一次。</p>\n<p>不过节流函数是如何做到的？ 以上方案例为例，绘制其流程图如下。  </p>\n<p>核心参数: </p>\n<ol>\n<li>间隔时长</li>\n<li>计时器</li>\n</ol>\n<pre><code>graph TB\n开始 --&gt; IF1{计时器是否为空}\n\nIF1 --&gt; |是| A(绘制圆点)\nA --&gt; B(添加计时器, 过了 间隔时长 后, 清除计时器)\nB --&gt; 结束\n\nIF1 --&gt; |否| 结束</code></pre><p>根据流程图的思路实现分流函数：</p>\n<pre><code class=\"language-js\">function throttle( func, wait ) {\n  let timer\n\n  function throttled( ...args ) {\n    const self = this\n\n    if ( timer == null ) {\n      invokeFunc()\n      addTimer()\n    }\n\n    function addTimer() {\n      timer = setTimeout( () =&gt; {\n        clearTimer()\n      }, wait )\n    }\n\n    function invokeFunc() {\n      func.apply( self, args )\n    }\n  }\n\n  return throttled\n\n  function clearTimer() {\n    clearTimeout( timer )\n    timer = null\n  }\n}</code></pre>\n<p>\b接下来，\b用编写的节流函数实现上方案例</p>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/throttle/test-mousemove/index.html?mode=result\" ></iframe>\n\n\n\n<h2 id=\"-\">应用场景</h2>\n<p>无限的滚动条</p>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/throttle/infinite-scrolling/index.html?mode=result\" ></iframe>\n\n\n\n<h2 id=\"-\">总结</h2>\n<p>节流和防抖类似，都能有效优化系统性能，不过使用业务场景有所区别：</p>\n<ul>\n<li>防抖既可用于在多次触发的事件（如文本框逐个输入文字），也可用于在频繁触发的事件（如调整窗口尺寸）。</li>\n<li>节流多只用在频繁触发的事件（如滚动滚动条）上。</li>\n</ul>\n","createTime":"2018/9/20 18:27","categorySequence":["所有分类","技术","JavaScript","专题"],"tags":[],"introduction":"节流(分流)，与防抖（去抖）实现原理相似。本文主要讨论节流，镜像文章：防抖 - 理解，实践与实现 [/cn/detail/debounce.html] 。分开讨论防抖和节流，主要是为了让一些还不太了解节流防抖的读者能够有针对性地，逐一掌握它们。...","uniqueHtmlName":"throttle","blogProps":{"name":"节流 - 理解，实践与实现","createTime":"2018/9/20 18:27","comment":"3"}},{"path":"/Users/suxing/Documents/TheWorkingDocuments/Item/Terry-Su.github.io/CN-Blogs/技术/JavaScript/专题/debounce/index.md","relativeClientUrl":"detail/debounce.html","relativeClientPropsUrl":"所有分类/技术/JavaScript/专题/debounce/props.json","name":"防抖 - 理解，实践与实现","markedHtml":"<p>防抖（去抖），以及节流（分流）在日常开发中可能用的不多，但在特定场景，却十分有用。本文主要讨论防抖，镜像文章：<a href=\"/cn/detail/throttle.html\">节流 - 理解，实践与实现</a>。分开讨论防抖和节流，主要是为了让一些还不太了解防抖节流的读者能够有针对性地，逐一掌握它们。<br>防抖有<strong>两种模式</strong>（容易让人迷惑）：延时执行和直接执行。后续详细讨论。<br>防抖还有一个关键点是如果用代码实现。本文以循序渐进地方式，先以实现一个简单案例为例，绘制流程图，再根据流程图逻辑编写防抖功能代码。</p>\n<h2 id=\"-\">典型案例</h2>\n<p>以日常开发中常用的搜索按钮为例，若用户点击一次搜索按钮后，不小心“手抖”很快又点了一次按钮，防抖可以规避第二次甚至更多次搜索。</p>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/search/index.html?mode=result\" ></iframe>\n\n<p>第一个搜索按钮未做任何防抖处理。<br>搜索按钮A为第一种防抖模式：延时执行。若用户连续快速点击多次，只有最后一次点击结束，延时一段时间后才执行搜索。<br>搜索按钮B为第二种防抖模式：直接执行。若用户连续快速点击多次，只有第一次点击会执行搜索。</p>\n<h2 id=\"-\">防抖\b是什么</h2>\n<p>结合上方案例，防抖可以理解为：多次触发事件后，事件处理函数只执行一次。<br>而防抖的两种模式可以根据实际使用场景分别应用。</p>\n<h2 id=\"-\">应用场景</h2>\n<p>在搜索框中实时键入文本搜索</p>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/realtime-search/index.html?mode=result\" ></iframe>\n\n<p>防止频繁点击搜索按钮触发搜索请求</p>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/standard-search/index.html?mode=result\" ></iframe>\n\n\n\n<h2 id=\"-\">一步步手写防抖</h2>\n<p>接下来我们通过一个案例梳理实现防抖的思路。<br>假设我们要实现本文第一个案例中搜索按钮A的功能。首先整理需求：</p>\n<ol>\n<li>点击搜索按钮后，函数并不马上执行，而是等一段时间再执行。 </li>\n<li>若在这段时间内，按钮再次被点击，则重新开始计时，等待同样一段时间后再执行。 </li>\n</ol>\n<p>实现的方法有两种，推荐第一种，用计时器(setTimeout)简化代码，将重心放在实现防抖的逻辑上。</p>\n<p>方法一核心参数：</p>\n<ol>\n<li>等待时长</li>\n<li>计时器</li>\n</ol>\n<p>绘制方法一的流程图：</p>\n<pre><code>graph TB\n开始--&gt; A{计时器是否为空}\nA--&gt; |是| B(添加计时器: 过了 等待时长 后, 执行搜索,然后 清除计时器)\nA--&gt; |否| C(清除计时器)\nC--&gt; B\nB--&gt; 结束</code></pre><p>根据流程图思路实现方法一的防抖代码：</p>\n<pre><code class=\"language-js\">function debounce( func, wait = 0 ) {\n  let timer\n\n  function debounced( ...args ) {\n    const self = this\n    if ( timer == null ) {\n      addTimer()\n      return\n    }\n\n    if ( timer != null ) {\n      clearTimer()\n      addTimer()\n      return\n    }\n\n    function addTimer() {\n      timer = setTimeout( () =&gt; {\n        invokeFunc()\n        clearTimer()\n      }, wait )\n    }\n\n    function invokeFunc() {\n      func.apply( self, args )\n    }\n  }\n\n  return debounced\n\n  function clearTimer() {\n    clearTimeout( timer )\n    timer = null\n  }\n}</code></pre>\n<p>方法二核心参数：</p>\n<ol>\n<li>等待时长</li>\n<li>最早可执行时间</li>\n</ol>\n<p>绘制方法二的流程图：</p>\n<pre><code>graph TB\n开始 --&gt; IF1{最早可执行时间 是否定义}\nIF1 --&gt; |是| IF2{当前时间 是否 大于或等于 最早可执行时间}\nIF1 --&gt; |否| A(设置 最早可执行时间 为 当前时间 加上 等待时长)\nIF2 --&gt; |是| B(执行搜索)\nIF2 --&gt; |否| A\n\nB --&gt; 结束\nA --&gt; 结束</code></pre><p>根据流程图实现方法二的防抖代码：</p>\n<pre><code class=\"language-js\">function debounce( func, wait = 0 ) {\n  // Earliest time when func can be invoked\n  let earliest\n\n  function debounced( ...args ) {\n    const self = this\n\n    if ( typeof earliest === &#39;undefined&#39; ) {\n      setEarliset()\n    }\n\n    if ( typeof earliest !== &#39;undefined&#39; ) {\n      if ( now() &gt;= earliest ) {\n        invokeFun()\n      } else {\n        setEarliset()\n      }\n    }\n\n    function setEarliset() {\n      earliest = now() + wait\n    }\n\n    function invokeFun() {\n      func.apply( self, args )\n    }\n  }\n\n  return debounced\n\n  function now() {\n    return +new Date()\n  }\n}</code></pre>\n<p>同样，我们可以使用类似方法实现搜索按钮B的功能。\n需求描述：</p>\n<ol>\n<li>点击搜索按钮后，函数马上执行。只有等待一段时间后被点击才能执行函数。</li>\n<li>若在这段时间内按钮被点击，则重新计时。</li>\n</ol>\n<p>核心参数：</p>\n<ol>\n<li>等待时长</li>\n<li>计时器</li>\n</ol>\n<pre><code>graph TB\n开始--&gt; IF1{计时器是否为空}\nIF1 --&gt; |是| B(执行搜索)\nB--&gt; C(添加计时器: 过了 等待时长 后, 清除计时器)\n\n\nIF1 --&gt; |否|D(清除计时器)\nD--&gt; C\n\nC--&gt; 结束</code></pre><pre><code class=\"language-js\">function debounce( func, wait = 0 ) {\n  let timer\n\n  function debounced( ...args ) {\n    const self = this\n\n    timer == null &amp;&amp; invokeFunc()\n\n    timer != null &amp;&amp; clearTimer()\n\n    timer = setTimeout( clearTimer, wait )\n\n    function invokeFunc() {\n      func.apply( self, args )\n    }\n  }\n\n  return debounced\n\n  function clearTimer() {\n    clearTimeout( timer )\n    timer = null\n  }\n}</code></pre>\n<p>接下来我们使用刚才编写的debounce函数来测试第一个案例</p>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/test-search/index.html?mode=js\" ></iframe>\n\n\n<h2 id=\"-\">总结</h2>\n<p>防抖是一个高阶函数，能够将多个事件函数合并为一个，在“调整window尺寸”，“在搜索框中实时搜索键入文本”， “滚动滚动条”和“防止搜索按钮频繁点击触发多余请求”等案例中，十分有用。</p>\n<h2 id=\"-\">链接</h2>\n<ul>\n<li>Lodash推荐：<a href=\"https://css-tricks.com/debouncing-throttling-explained-examples\">https://css-tricks.com/debouncing-throttling-explained-examples</a></li>\n<li>简单理解防抖定义：<a href=\"https://www.cnblogs.com/woodyblog/p/6238445.html\">https://www.cnblogs.com/woodyblog/p/6238445.html</a></li>\n</ul>\n","createTime":"2018/9/19 18:02","categorySequence":["所有分类","技术","JavaScript","专题"],"tags":[],"introduction":"防抖（去抖），以及节流（分流）在日常开发中可能用的不多，但在特定场景，却十分有用。本文主要讨论防抖，镜像文章：节流 - 理解，实践与实现 [/cn/detail/throttle.html]。分开讨论防抖和节流，主要是为了让一些还不太了解防抖节流的读者能够有针对性地，逐一掌握它们。...","uniqueHtmlName":"debounce","blogProps":{"name":"防抖 - 理解，实践与实现","createTime":"2018/9/19 18:02","comment":"2"}}]}
